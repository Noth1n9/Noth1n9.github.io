{"pages":[],"posts":[{"title":"Cache","text":"&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; —— Noth1n9 缓存 缓存是位于CPU和内存之间的临时存储器，它的容量比内存小的多但是交换速度却比内存要快得多。 缓存能够解决CPU运算速度与内存读写速度不匹配的矛盾，因为CPU运算速度要比内存读写速度快很多，这样会使CPU花费很长时间等待数据。 缓存命中123456# 代码1int arr[100][100];for(int i = 0; i &lt; 100; i++) for(int j = 0; j &lt; 100; j++) arr[i][j] = 1; 123456# 代码2int arr[100][100];for(int i = 0; i &lt; 100; i++) for(int j = 0; j &lt; 100; j++) arr[j][i] = 1; 上述两段代码看似没有什么区别，但由于缓存命中的问题，会导致速度上的差异。计算机的CPU与缓存和主存之间进行数据交换具有很大的时间差异，因此能直接在缓存中找到数据时，也就是缓存命中时，能有较快的速度。 缓存由多个cache line组成，cache line是缓存和主存之间数据传输的最小单位，当把数据加载到缓存中时，那么缓存控制器会从主存中一次性加载cache line大小的数据。 因此当执行arr[0][0] = 1时，缓存控制器发现arr[0][0]不在缓存中，也就是缓存不命中，需要去主存中进行读取并将数据加载到缓存中。假设此时cache line的大小为64字节，会从主存中读取arr[0][0]到arr[0][15]的数据到内存中。当执行访问arr[0][1]时，在缓存中能找到其位置，也就是缓存命中，此时的访问速度较快。 而对于代码2，当执行arr[0][0] = 1时，缓存控制器同样发现arr[0][0]不在缓存中，需要去主存中进行读取并将数据加载到缓存中，同样也会从主存中读取arr[0][0]到arr[0][15]的数据到内存中。当第二轮读取arr[1][0]时依然会发生缓存不命中，并且一直到arr[99][0]都是不命中。那么当访问arr[0][1]会是怎么情况呢？ 此时就需要考虑缓存的大小了。如果缓存大小大于数组arr大小，缓存此时相当于缓存了整个arr数组的内容。那么后续访问其他元素，确实是缓存命中。似乎和代码1分析结果差不多。但是如果缓存的大小很小，例如只有数组一半大小，那么缓存命中率就很明显会降低。同样的缓存大小，代码1依然会获得很高的缓存命中率。","link":"/2021/04/01/cache/"},{"title":"transformer","text":"&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; —— Noth1n9","link":"/2021/04/07/transformer/"}],"tags":[],"categories":[{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"深度学习","slug":"深度学习","link":"/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"自然语言处理","slug":"深度学习/自然语言处理","link":"/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"}]}